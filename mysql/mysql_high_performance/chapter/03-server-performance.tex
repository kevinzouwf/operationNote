
性能的定义为：完成某件任务所需要的时间度量

假如你认为性能优化是降低cpu利用率，那么可以减少对资源的使用。但这是一个陷阱，资源是用来消耗并用来工作的。
所以有时候消耗更多的资源能够加快查询速度，很多时间使用老版本的InnoDB引擎的mysql升级到新版后，CPU利用率上升得很厉害，
这并不代表性能出现了问题，反而说明新版本的InnoDB对资源利用率上升了，查询响应时间则更能体现升级后性能是不是变得更好。
版本升级有时候会带来一些bug，比如不能利用某些索引从而导致CPU利用率上升，CPU利用率上升只是一个现象，而不是很好的可度量的目标。

如果性能优化仅仅看成是提升每秒查询量，这其实只是吞吐量优化，吞吐量的提升可以看作性能优化的副产品，对查询的优化可以让服务器
每秒执行更多的查询，因为每条查询执行的时间更短了。（吞吐量的定义是单位时间内的查询数量，这正好是我们对性能的定义的倒数）

所以如果目录是降低响应时间，那么就需要理解为什么服务器执行查询需要这么多时间，然后去减少或者消除那些对查询结果来说不必要的工作。
也就是说要先搞清楚时间花在那里，这就引申出优化的第二个原则： 无法测量就无法有效地优化。



完成一项任务所需要的时间可以分成两部分： 执行时间等待时间。如果要优化任务的执行时间，最好的办法是通过测量定位不同的了任务花费的时间
然后优化去掉一些子任务，降低子任务的执行频率或者提升子任务的效率。优化任务的等待时间刚相对要复杂一些，因为等待有可能是由其他系统间接
影响导致，任务之间也可能由于争用磁盘或者CPU资源


性能剖析(profile) 并不会自动给出那些查询值得花时间去优化，读过Cary Millsap的书对此会有更多的理解，
现在强调两点： 一些只占总响应时间比重很小的查询是不值得优化的，根据阿姆达尔定律（Amdahl's law) ，对一个占总响应时间不超过5\% 的查询进行优化，
无论如何努力，收益也不会超过5\%，第二：如果花费了1000美元优化一个任务，但业务的收入没有任何增加，那么可以说反而导致业务被逆优化了1000美元。
如果优化的成本大于收益，就应当停止优化。

某些任务即使没有出现在性能剖析输出的前面也需要优化。比如某些任务执行次数很少，但每次执行都非常慢，严重影响用户体验。一款性能剖析工具会显示可能丢失
的时间，丢失的时间指的是任务的总时间和实际测量到的时间之间的差。如果发现这类问题刚要引起重视，因为有可能错过某些重要的事情。

性能瓶颈并不只是在mysql上，有很多影响因素：

外部资源： 比如调用了外部的web服务或者搜索引擎
应用需要处理大理的数据，比如分析一个超大的xml文件
在循环中执行昂贵的操作，比如滥用正则表达式
使用了低效的算法，比如使用暴力搜索算法(naive search algorithm)

虽然性能剖析和定期检测都会带来额外的开销，问题在于这部分开销有多少，并且由此获得的收益是否能够抵消这些开销。测量点至少为性能优化贡献了10\%
如果系统没有每天变化的性能统计，则碰到无法提前预知的性能瓶颈就是一件头痛的事情，发现问题的时候，如果有历史数据，刚这些奋勉数据价值是无限的。
而且性能数据还可以帮助规划好硬件采购，资源分配，以及预测周期性的性能尖峰。New Relic 的软件及服务进行性能测量

php有一个叫xhprof这是facebook开发给内部使用的。2009年开源。其轻量级，可扩展性也很好。
还有一些软件xdebug, valgrind,cachegrind这些开销很大，可以在开发环境发挥很大作用
还有作者自己写的IfP（instrumentation-for-php)

pt-query-digest 通过processlist 不断查看 show full processlist的输出。记录查询第一次出现的时间和消失时间，或者通过抓取TCP网络包，然后根据mysql的客户端/服务端
通信协议进行解析，选 通过tcpdump将网络包数据保存到磁盘，然后通过 pt-query-digest --type=tcpdump选项来解析并分析查询。

pt-query-digest 也可以分析慢查询日志。所以并不需要直接打开慢查询日志，因为这会会浪费时间和金钱。

表名后面有问号说明这是一个分片的表(shard), V/M 提供了方差基均值(variance-to-mean ratio) 方差均值也就是常说的离差指数(index of dispersion)。
离差指数高的查询对应的执行时间变化较大，而这类查询通常值得去优化。  如果指定了--explain选项，输出结果会增加一列简要描述查询的执行计划。
执行计划是查询背后的“极客代码”。
最后在尾部也增加了一行输出，显示了其他n个占比较低而不值得单独显示的查询的统计数据。可能通过--limit和--outliners选项指定工具显示更多查询的详细信息。
默认只会打印时间消耗前10位的查询。

剖析报告后面包含了每种查询的详细报告，可以通过查询的ID或者排名来匹配前面的剖析报告和查询的详细报告。

报告顶部包括了查询执行的频率，平均并发度，以及该查询性能最差的一次执行在日志文件中的字节偏移值。接下来是query_time distribution直方图。

show status最有用的计数器包括句柄计数器(handler counter)，临时文件和表计数器等。

可以使用pt-collect可以收集尽可能多的数据，默认情况下启动后收集30秒的数据，然后退出。对于大多数问题的诊断来说，这已经足够。
一般pt-coolect使用pt-stalk调用，pt-stalk,用来监控服务器，当达到触发条件时能收集数据，
系统中最好安装gdb和oprofile然后在pt-stalk中配置使用，另外mysql也需要有调试符号信息(可以使用nm工具检查是否安装符号信息)。当触发条件满足时，
pt-collect会很好的收集完整的数据。它也会在目录中创建时间戳文件。

pt-mysql-summary pt-summary会输出myusql的状态和配置信息，以及操作系统和硬件信息。

pt-sift这个工具会轮流导航所有的样本数据，得到每个样本的汇总信息。

穷人剖析器'poor man's profiler' www.poormansprofiler.org 类似穷人剖析器的是pt-pmp这是一个用shell和awk脚本编写的工具，可以将类似的堆栈跟踪输出合并在一起
然后通过sort|uniq|sort将最常见的条目在最前面输出。


